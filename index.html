<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEXUS v8.1 â€” Temporal Offset Lead</title>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>

  <style>
    :root { --quantum: #00e5ff; --neural: #ff00ff; --bg: #000; }
    * { margin:0; padding:0; box-sizing:border-box; cursor: none !important; }
    body { background: var(--bg); color: #fff; font-family: 'JetBrains Mono', monospace; overflow: hidden; }

    #cursor {
      position: fixed;
      width: 14px;
      height: 14px;
      border: 1px solid #fff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      mix-blend-mode: difference;
    }

    .widget {
      position: fixed;
      background: rgba(5,5,15,0.92);
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
    
    #temporal-ctrl { top: 24px; left: 24px; width: 360px; border-top: 3px solid var(--neural); }
    #parallel-stats { bottom: 24px; left: 24px; width: 360px; font-size: 10px; }

    input[type=range] {
      width: 100%;
      accent-color: var(--neural);
      margin-top: 12px;
    }
    .label {
      font-size: 9px;
      color: var(--quantum);
      letter-spacing: 2.5px;
      text-transform: uppercase;
    }
    .btn {
      width: 100%;
      padding: 14px;
      background: var(--quantum);
      color: #000;
      border: none;
      font-weight: 900;
      cursor: pointer;
      margin-top: 18px;
      border-radius: 6px;
      transition: all 0.2s;
    }
    .btn:hover { background: #00ffff; box-shadow: 0 0 30px #00ffff44; }

    #viewport { width: 100vw; height: 100vh; }
  </style>
</head>
<body>

<div id="cursor"></div>

<div id="temporal-ctrl" class="widget">
  <span class="label">NEURAL PROJECTION LEAD</span>
  <input type="range" id="dilation" min="0" max="100" value="30">
  <div style="display:flex; justify-content: space-between; font-size: 9px; margin-top:8px;">
    <span>REAL-TIME</span>
    <span>FUTURE_OFFSET</span>
  </div>
  <button class="btn" onclick="spawn(20)">INJECT TEMPORAL NODES</button>
</div>

<div id="parallel-stats" class="widget">
  <div id="thread-readout">THREADS: ACTIVE // PARALLEL_SYNC: <span id="sync-pct">100</span>%</div>
  <div style="color:var(--neural); margin-top:8px;" id="prediction-info">Neural Lead: 0.0s</div>
</div>

<div id="viewport"></div>

<script>
let scene, camera, renderer, world, entities = [];

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(140, 120, 140);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('viewport').appendChild(renderer.domElement);

  new THREE.OrbitControls(camera, renderer.domElement);

  world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });

  const ground = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
  ground.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
  world.addBody(ground);

  window.onmousemove = e => {
    document.getElementById('cursor').style.left = e.clientX + 'px';
    document.getElementById('cursor').style.top = e.clientY + 'px';
  };

  animate();
}

function spawn(count) {
  const geo = new THREE.SphereGeometry(2.2, 24, 24);
  for(let i = 0; i < count; i++) {
    const mat = new THREE.MeshStandardMaterial({ 
      color: 0x00e5ff, 
      metalness: 0.6, 
      roughness: 0.15,
      emissive: 0x00aaff,
      emissiveIntensity: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    
    const body = new CANNON.Body({ 
      mass: 1.2, 
      shape: new CANNON.Sphere(2.2),
      linearDamping: 0.02,
      angularDamping: 0.02
    });
    body.position.set(
      (Math.random()-0.5)*140,
      80 + (i*6),
      (Math.random()-0.5)*140
    );

    // Neural ghost (predictive future)
    const ghostMat = new THREE.MeshBasicMaterial({
      color: 0xff00ff,
      wireframe: true,
      transparent: true,
      opacity: 0.35
    });
    const ghost = new THREE.Mesh(geo, ghostMat);

    scene.add(mesh);
    scene.add(ghost);
    world.addBody(body);

    // Simple spawn animation
    mesh.scale.set(0.01,0.01,0.01);
    ghost.scale.set(0.01,0.01,0.01);
    let t = 0;
    const anim = setInterval(() => {
      t += 0.08;
      const s = Math.min(1, t);
      mesh.scale.set(s,s,s);
      ghost.scale.set(s,s,s);
      if (t >= 1) clearInterval(anim);
    }, 16);

    entities.push({ mesh, body, ghost });
  }
}

function animate() {
  requestAnimationFrame(animate);

  const dilation = document.getElementById('dilation').value / 100; // 0..1
  const leadTime = dilation * 12; // max 12 seconds lead
  document.getElementById('prediction-info').innerText = `Neural Lead: ${leadTime.toFixed(1)}s`;
  document.getElementById('sync-pct').innerText = Math.round(100 - dilation*40); // fake desync

  // Dilated real physics (slower when slider is right)
  world.step(1/60 * (1 - dilation*0.8));

  entities.forEach((e, idx) => {
    e.mesh.position.copy(e.body.position);
    e.mesh.quaternion.copy(e.body.quaternion);

    // Predictive ghost: integrate velocity + gravity over lead time
    const vel = e.body.velocity;
    const pos = e.body.position;

    let futureX = pos.x + vel.x * leadTime;
    let futureY = pos.y + vel.y * leadTime - 0.5 * 9.81 * leadTime**2;
    let futureZ = pos.z + vel.z * leadTime;

    // Clamp to ground (simple)
    futureY = Math.max(futureY, 2.2);

    e.ghost.position.set(futureX, futureY, futureZ);

    // Cleanup far below ground
    if (pos.y < -80) {
      scene.remove(e.mesh);
      scene.remove(e.ghost);
      world.removeBody(e.body);
      entities.splice(idx, 1);
    }
  });

  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
