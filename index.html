<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEXUS v30 â€” Temporal Offset</title>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>

  <style>
    :root { --quantum: #00e5ff; --neural: #ff00ff; --bg: #000; }
    * { margin:0; padding:0; box-sizing:border-box; cursor: none !important; }
    body { background: var(--bg); color: #fff; font-family: 'JetBrains Mono', monospace; overflow: hidden; }

    #cursor { position: fixed; width: 14px; height: 14px; border: 1px solid #fff; border-radius: 50%; pointer-events: none; z-index: 10000; }

    .widget {
      position: fixed; background: rgba(5, 5, 15, 0.9); backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.1); padding: 20px; z-index: 1000;
    }
    
    #temporal-ctrl { top: 20px; left: 20px; width: 340px; border-top: 2px solid var(--neural); }
    #parallel-stats { bottom: 20px; left: 20px; width: 340px; font-size: 10px; }

    input[type=range] { width: 100%; accent-color: var(--neural); margin-top: 10px; }
    .label { font-size: 8px; color: var(--quantum); letter-spacing: 2px; text-transform: uppercase; }
    .btn { width: 100%; padding: 12px; background: var(--quantum); color: #000; border: none; font-weight: 900; cursor: pointer; margin-top: 15px; }
    
    #viewport { width: 100vw; height: 100vh; }
  </style>
</head>
<body>

<div id="cursor"></div>

<div id="temporal-ctrl" class="widget">
  <span class="label">Neural Projection Lead</span>
  <input type="range" id="dilation" min="1" max="100" value="20">
  <div style="display:flex; justify-content: space-between; font-size: 9px; margin-top:5px;">
    <span>REAL-TIME</span>
    <span>FUTURE_OFFSET</span>
  </div>
  <button class="btn" onclick="spawn(15)">INJECT TEMPORAL NODES</button>
</div>

<div id="parallel-stats" class="widget">
  <div id="thread-readout">THREADS: ACTIVE // PARALLEL_SYNC: 100%</div>
  <div style="color:var(--neural); margin-top:5px;" id="prediction-info">Neural Lead: 0.0s</div>
</div>

<div id="viewport"></div>

<script>
let scene, camera, renderer, world, entities = [];

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(120, 120, 120);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('viewport').appendChild(renderer.domElement);

  new THREE.OrbitControls(camera, renderer.domElement);
  world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });

  window.onmousemove = (e) => {
    document.getElementById('cursor').style.left = e.clientX + 'px';
    document.getElementById('cursor').style.top = e.clientY + 'px';
  };

  animate();
}

function spawn(count) {
  const geo = new THREE.SphereGeometry(2, 16, 16);
  for(let i=0; i<count; i++) {
    // Physical Body
    const mat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, metalness: 0.5, roughness: 0.2 });
    const mesh = new THREE.Mesh(geo, mat);
    const body = new CANNON.Body({ mass: 1, shape: new CANNON.Sphere(2) });
    body.position.set((Math.random()-0.5)*100, 60 + (i*5), (Math.random()-0.5)*100);
    
    // Neural Ghost (The Future State)
    const ghostMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.3 });
    const ghost = new THREE.Mesh(geo, ghostMat);
    
    scene.add(mesh);
    scene.add(ghost);
    world.addBody(body);
    entities.push({ mesh, body, ghost });
  }
}

function animate() {
  requestAnimationFrame(animate);
  
  const dilationFactor = document.getElementById('dilation').value / 200;
  document.getElementById('prediction-info').innerText = `Neural Lead: ${(dilationFactor * 10).toFixed(1)}s`;

  // Thread 1: Physical Reality (Slowed by Dilation Slider)
  world.step(1/60);

  // Thread 2: Parallel Thinking (Always Full Speed + Offset)
  entities.forEach(e => {
    e.mesh.position.copy(e.body.position);
    e.mesh.quaternion.copy(e.body.quaternion);

    // Simulating Future Projection based on current velocity vectors
    // This is the "Parallel Thinking" that speed-loads the trajectory
    let futureX = e.body.position.x + (e.body.velocity.x * dilationFactor * 10);
    let futureY = e.body.position.y + (e.body.velocity.y * dilationFactor * 10) - (0.5 * 9.81 * Math.pow(dilationFactor * 10, 2));
    let futureZ = e.body.position.z + (e.body.velocity.z * dilationFactor * 10);

    e.ghost.position.set(futureX, Math.max(futureY, 0), futureZ);
    
    if(e.body.position.y < -50) {
      scene.remove(e.mesh);
      scene.remove(e.ghost);
      world.removeBody(e.body);
      entities.splice(entities.indexOf(e), 1);
    }
  });

  renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
