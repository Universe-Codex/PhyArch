<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>NEXUS â€” Temporal Projection Dashboard</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #1a1a20;
      --surface-elevated: #22222a;
      --text-primary: #ffffff;
      --text-secondary: #a0a0b0;
      --accent: #3b82f6;
      --border: #2a2a35;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: var(--bg);
      color: var(--text-primary);
      font-family: 'Inter', system-ui, sans-serif;
      overflow: hidden;
      height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    .hud {
      position: fixed;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      z-index: 1000;
      transition: all 0.3s ease;
    }
    #lead-hud {
      top: 24px;
      left: 24px;
      width: 380px;
    }
    #status-hud {
      bottom: 24px;
      left: 24px;
      width: 380px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    h2 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
    }

    .slider-container {
      margin: 16px 0;
    }
    input[type=range] {
      width: 100%;
      height: 8px;
      background: var(--surface-elevated);
      border-radius: 4px;
      -webkit-appearance: none;
      outline: none;
      transition: background 0.3s;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(59,130,246,0.4);
      transition: transform 0.2s;
    }
    input[type=range]:active::-webkit-slider-thumb {
      transform: scale(1.2);
    }

    .label-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .btn {
      width: 100%;
      padding: 16px;
      background: var(--accent);
      color: white;
      border: none;
      font-weight: 600;
      font-size: 15px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(59,130,246,0.3);
    }
    .btn:active {
      transform: scale(0.98);
      box-shadow: 0 2px 8px rgba(59,130,246,0.5);
    }

    #viewport {
      width: 100vw;
      height: 100vh;
      background: var(--bg);
    }
  </style>
</head>
<body>

<div id="lead-hud" class="hud">
  <h2>Neural Projection Lead</h2>
  <div class="label-row">
    <span>Real-time</span>
    <span>Future offset</span>
  </div>
  <div class="slider-container">
    <input type="range" id="lead" min="0" max="100" value="40">
  </div>
  <button class="btn" onclick="injectNodes(28)">Inject Temporal Nodes</button>
</div>

<div id="status-hud" class="hud">
  <div>Threads: Active // Sync: <span id="sync">100</span>%</div>
  <div style="margin-top:8px;">Neural lead: <span id="lead-val">0.0</span>s</div>
</div>

<div id="viewport"></div>

<script>
// Minimal self-contained engine for offline demo
let scene = { children: [], background: {r:15,g:15,b:18} };
let camera = { position: {x:180,y:160,z:180} };
let renderer = { domElement: document.createElement('canvas'), setSize: (w,h) => { renderer.domElement.width = w; renderer.domElement.height = h; }, render: () => {} };
document.getElementById('viewport').appendChild(renderer.domElement);

let controls = { enableDamping: true, update: () => {} };

let world = { gravity: {x:0,y:-12,z:0}, step: () => {} };
let entities = [];

function injectNodes(count = 28) {
  for(let i = 0; i < count; i++) {
    const mesh = { position: {x:(Math.random()-0.5)*240, y:140+i*10, z:(Math.random()-0.5)*240}, scale: {x:0.1,y:0.1,z:0.1} };
    const body = { position: mesh.position, velocity: {x:0,y:0,z:0} };
    const ghost = { position: {x:0,y:0,z:0} };

    // Spawn animation
    let t = 0;
    const grow = setInterval(() => {
      t += 0.12;
      const s = Math.min(1, t);
      mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
      if (t >= 1) clearInterval(grow);
    }, 16);

    entities.push({mesh, body, ghost});
  }
}

function animate() {
  requestAnimationFrame(animate);

  const lead = document.getElementById('lead').value / 100;
  const leadSec = lead * 20;
  document.getElementById('lead-val').innerText = leadSec.toFixed(1);
  document.getElementById('sync').innerText = Math.round(100 - lead*80);

  // Simulate dilated physics
  entities.forEach(e => {
    e.mesh.position.y -= 0.12 * (1 - lead);
    e.ghost.position.y = e.mesh.position.y + e.body.velocity.y * leadSec - 4.905 * leadSec**2;
    e.ghost.position.x = e.mesh.position.x + e.body.velocity.x * leadSec;
    e.ghost.position.z = e.mesh.position.z + e.body.velocity.z * leadSec;
  });

  controls.update();
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
